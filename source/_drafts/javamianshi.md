作者：周立
链接：https://zhuanlan.zhihu.com/p/28515841
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

Java 的三大特性封装、继承、多态抽象类和接口的区别 Java 抽象类： 使用关键字 abstract 修饰的类叫做抽象类。 用 abstract 来修饰的方法叫做抽象方法。 特点： 1 含有抽象方法的类必须被声明为抽象类（不管是否还包含其他一般方法）（否则编译通不过）； 2 抽象类可以没有抽象方法，可以有普通方法。 3 抽象类必须被继承，抽象方法必须被重写： 若子类还是一个抽象类，不需要重写；否则必须要重写（override）。 抽象类不能被实例化（不能直接构造一个该类的对象）；抽象方法： 在类中没有方法体（抽象方法只需声明，而不需实现某些功能）； 抽象类中的抽象方法必须被实现； 如果一个子类没有实现父类中的抽象方法，则子类也变成了一个抽象类；虚方法： 虚函数的存在是为了多态。 Java 中没有虚函数的概念。它的普通函数就相当于 c++的虚函数，动态绑定是 java 的默认行为。如果 java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变为非虚函数。Java 接口： 是一系列方法的声明。 1 只有声明没有实现； 2 在不同的类中有不同的方法实现；共同点 1、接口和抽象类都不能被实例化，他们都位于继承树的顶端，用于被其他类实现和继承。 2、接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些方法。不同点 1、接口里只能包含抽象方法和默认方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法。 2、接口里不能定义静态方法，抽象类里可以定义静态方法。 3、接口里只能定义静态常量，不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量。 4、接口里不包含构造器，抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。 5、接口里不能包含初始化块，但抽象类则完全可以包含初始化块。 6、一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补 Java 单继承的不足。栈内存和堆内存，引用和值传递栈内存、堆内存在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块中定义一个变量时，java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，java 会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。 堆内存用于存放由 new 创建的对象和数组。在堆中分配的内存，由 java 虚拟机自动垃圾回收器来管理。在数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是 java 比较占内存的主要原因。引用、值传递值传递：方法调用时，实际参数把它的值传递给对应的形式参数，方法执行中形式参数值的改变不影响实际参数的值。引用传递：也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，方法执行中形式参数值的改变将会影响实际参数的值。单例模式及好处构造函数私有化，用一个静态方法来获取对象实例。特点： 1）单例类只能有一个实例。 2）单例类必须自己创建自己的唯一实例。 3）单例类必须给所有其他对象提供这一实例。 主要优点： 1）提供了对唯一实例的受控访问。 2）由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。 3）允许可变数目的实例。主要缺点： 1）由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。 2）单例类的职责过重，在一定程度上违背了“单一职责原则”。 3）滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。重载和重写重载：Overloading （1） Java 的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。 （2） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回类型作为重载函数的区分标准。重写：Overriding 注意：当要重写父类方法时，要使用@Override 标签提醒编译器检查代码是否是重写，而不是重载了原来的方法。 （1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在 Java 中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。 （2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。如需父类中原有的方法，可使用 super 关键字，该关键字引用了当前类的父类。 （3）子类函数的访问修饰权限不能少于父类的。子类、父类间的转换和构造顺序子类、父类间的转换： 子类能够自动转换成父类类型。 当创建子类对象的时候： ① 先调用了子类的构造函数 ② 调用了父类的构造函数 ③ 执行了父类的构造函数 ④ 执行了子类的构造函数 Final、finally、finalizefinal 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 finally 是异常处理语句结构的一部分，表示总是执行。 finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等 Synchronized 和 volatile 的区别 volatile 只作用于在多个线程之间能够被共享的变量。如果一个字段被声明成 volatile，java 线程内存模型确保所有线程看到这个变量的值是一致的。Volatile 变量修饰符如果使用恰当的话，它比 synchronized 的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。 synchronized 获得并释放监视器——如果两个线程使用了同一个对象锁，监视器能强制保证代码块同时只被一个线程所执行——这是众所周知的事实。但是，synchronized 也同步内存：事实上，synchronized 在“ 主”内存区域同步整个线程的内存。 因此 volatile 只是在线程内存和“主”内存间同步某个变量的值，而 synchronized 通过锁定和解锁某个监视器同步所有变量的值。显然 synchronized 要比 volatile 消耗更多资源。1）volatile 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取，没有互斥锁；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 2）volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的 3）volatile 只是在线程内存和“主”内存间同步某个变量的值，而 synchronized 通过锁定和解锁某个监视器同步所有变量的值；显然 synchronized 要比 volatile 消耗更多资源。 4）volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。 5）volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化 。集合 Collection：代表一组对象，每一个对象都是它的子元素。 Set：不包含重复元素的 Collection。 List：有顺序的 Collection，并且可以包含重复元素。 Map：可以把键（key）映射到值（value）的对象，键不能重复。集合类没有实现 Cloneable 和 Serializable 接口的原因 Collection 接口指定一组对象，对象即为它的元素。如何维护这些元素由 Collection 的具体实现决定。例如，一些如 List 的 Collection 实现允许重复的元素，而其它的如 Set 就不允许。很多 Collection 实现有一个公有的 clone 方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为 Collection 是一个抽象表现。重要的是实现。 当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。 在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制。特定的实现应该决定它是否可以被克隆和序列化。hashCode()和 equals()方法的重要性体现在什么地方？HashMap 使用 Key 对象的 hashCode()和 equals()方法去决定 key-value 对的索引。当我们试着从 HashMap 中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同 Key 也许会产生相同的 hashCode()和 equals()输出，HashMap 将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。同样的，所有不允许存储重复数据的集合类都使用 hashCode()和 equals()去查找重复，所以正确实现它们非常重要。 equals()和 hashCode()的实现应该遵循以下规则： （1）如果 o1.equals(o2)，那么 o1.hashCode() == o2.hashCode()总是为 true 的。 （2）如果 o1.hashCode() == o2.hashCode()，并不意味着 o1.equals(o2)会为 true。 Java 中的 HashMap 使用 hashCode()和 equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的 hash 值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对 HashMap 的精确性和正确性是至关重要的。HashMap 和 HashTabel 的区别 HashMap 和 Hashtable 都实现了 Map 接口，因此很多特性非常相似。但是，他们有以下不同点： 1）HashMap 允许键和值是 null，而 Hashtable 不允许键或者值是 null。 2）Hashtable 是同步的，而 HashMap 不是。因此，HashMap 更适合于单线程环境，而 Hashtable 适合于多线程环境。 3）HashMap 提供了可供应用迭代的键的集合，因此，HashMap 是快速失败的。另一方面，Hashtable 提供了对键的列举(Enumeration)。 一般认为 Hashtable 是一个遗留的类。Comparable 和 Comparator 接口 Comparable 和 Comparator 都是用来实现集合中的排序的，只是 Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序，所以，如想实现排序，就需要在集合外定义 Comparator 接口的方法 compare()或在集合内实现 Comparable 接口的方法 compareTo()。 comparable 是支持自比较，而后者是支持外部比较； Comparable 是一个对象本身就已经支持自比较所需要实现的接口（如 String、Integer 自己就可以完成比较大小操作） 而 Comparator 是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。 也就是说当你需要对一个自定义的类的一个数组或者集合进行比较的时候可以实现 Comparable 接口，当你需要对一个已有的类的数组或者集合进行比较的时候就一定要实现 Comparator 接口。另外，这两个接口是支持泛型的，所以我们应该在实现接口的同时定义比较类型。Java 中 HashMap 的工作原理是？Java 中的 HashMap 是以键值对(key-value)的形式存储元素的。HashMap 需要一个 hash 函数，它使用 hashCode()和 equals()方法来向集合/从集合添加和检索元素。当调用 put()方法的时候，HashMap 会计算 key 的 hash 值，然后把键值对存储在集合中合适的索引上。如果 key 已经存在了，value 会被更新成新值。HashMap 的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。 1)HashMap 有一个叫做 Entry 的内部类，它用来存储 key-value 对。 2)上面的 Entry 对象是存储在一个叫做 table 的 Entry 数组中。 3)table 的索引在逻辑上叫做“桶”(bucket)，它存储了链表的第一个元素。 4)key 的 hashcode()方法用来找到 Entry 对象所在的桶。 5)如果两个 key 有相同的 hash 值，他们会被放在 table 数组的同一个桶里面。 6)key 的 equals()方法用来确保 key 的唯一性。 7)value 对象的 equals()和 hashcode()方法根本一点用也没有。 重点内容 Put：根据 key 的 hashcode()方法计算出来的 hash 值来决定 key 在 Entry 数组的索引。 Get：通过 hashcode 找到数组中的某一个元素 EntryHashcode 的实现 hashCode 的常规协定是： 在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。 当 equals 方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。String、StringBffer、StringBuilder 的区别 1）可变与不可变 String 类中使用字符数组保存字符串，如下就是，因为有“final”修饰符，所以可以知道 string 对象是不可变的。 　　　　 private final char value[]; StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，如下就是，可知这两种对象都是可变的。 　　　　 char[] value; 2）是否多线程安全 String 中的对象是不可变的，也就可以理解为常量，显然线程安全。 AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。 　　 StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的 1、具有 1-5 工作经验的，面对目前流行的技术不知从何下手，需要突破技术瓶颈的可以加群。2、在公司待久了，过得很安逸，但跳槽时面试碰壁。需要在短时间内进修、跳槽拿高薪的可以加群。3、如果没有工作经验，但基础非常扎实，对 java 工作机制，常用设计思想，常用 java 开发框架掌握熟练的，可以加群。4、觉得自己很牛 B，一般需求都能搞定。但是所学的知识点没有系统化，很难在技术领域继续突破的可以加群。5. 群号：高级架构群 647631030 点击链接加入群【JAVA 高级开发】：申请加入 QQ 群 备注好信息！6.阿里 Java 高级大牛直播讲解知识点，分享知识，多年工作经验的梳理和总结，带着大家全面、科学地建立自己的技术体系和技术认知！HashMap、HashSet、HashTable 的区别 HashSet 和 HashMap 的区别 1)HashSet 是 set 的一个实现类,hashMap 是 Map 的一个实现类,同时 hashMap 是 hashTable 的替代品. 2)HashSet 以对象作为元素,而 HashMap 以(key-value)的一组对象作为元素,且 HashSet 拒绝接受重复的对象.HashMap 可以看作三个视图：key 的 Set，value 的 Collection，Entry 的 Set。HashSet 其实就是 HashMap 的一个视图。HashSet 内部就是使用 Hashmap 实现的，和 Hashmap 不同的是它不需要 Key 和 Value 两个值。 往 hashset 中插入对象其实只不过是内部做了 public boolean add(Object o) { return map.put(o, PRESENT)==null; }hastTable 和 hashMap 的区别: 1)Hashtable 是基于陈旧的 Dictionary 类的，HashMap 是 Java 1.2 引进的 Map 接口的一个实现。 2)这个不同即是最重要的一点:Hashtable 中的方法是同步的，而 HashMap 方法(在缺省情况下)是非同步的。即是说，在多线程应用程序中，不用专门的操作就安全地可以使用 Hashtable 了；而对于 HashMap，则需要额外的同步机制。 3)只有 HashMap 可以让你将空值作为一个表的条目的 key 或 value。HashMap 中只有一条记录可以是一个空的 key，但任意数量的条目可以是空的 value。这就是说，如果在表中没有发现搜索键，或者如果发现了搜索键，但它是一个空的值，那么 get()将返回 null。如果有必要，用 containKey()方法来区别这两种情况。线程安全的 HashMap —— java.util.concurrent.ConcurrentHashMap ConcurrentHashMap 增加了 Segment 层，每个 Segment 原理上等同于一个 Hashtable， ConcurrentHashMap 为 Segment 的数组。 向 ConcurrentHashMap 中插入数据或者读取数据，首先都要讲相应的 Key 映射到对应的 Segment，因此不用锁定整个类， 只要对单个的 Segment 操作进行上锁操作就可以了。理论上如果有 n 个 Segment，那么最多可以同时支持 n 个线程的并发访问，从而大大提高了并发访问的效率。另外 rehash() 操作也是对单个的 Segment 进行的，所以由 Map 中的数据量增加导致的 rehash 的成本也是比较低的。附一篇博客：线程安全的 HashMap 实现方法及原理 http://liqianglv2005.iteye.com/blog/2025016ArrayList和LingkedList的区别1）ArrayList：底层用数组实现的List 特点：查询效率高，增删效率低 轻量级 线程不安全 2）LinkedList：底层用双向循环链表 实现的 List 特点：查询效率低，增删效率高垃圾回收机制 Java 的垃圾回收机制是 Java 虚拟机提供的能力，用于在空闲时间以不定时的方式动态回收无任何引用的对象占据的内存空间。 需要注意的是：垃圾回收回收的是无任何引用的对象占据的内存空间而不是对象本身。 两种常用的方法是引用计数和对象引用遍历。 引用计数：在这种方法中，堆中每个对象（不是引用）都有一个引用计数。当一个对象被创建时，且将该对象分配给一个变量，该变量计数设置为 1。当任何其它变量被赋值为这个对象的引用时，计数加 1（a = b,则 b 引用的对象+1），但当一个对象的某个引用超过了生命周期或者被设置为一个新值时，对象的引用计数减 1。任何引用计数为 0 的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减 1。 对象引用遍历：从一组对象开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集。序列化和反序列化序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。 序列化的目的　　 1、以某种存储形式使自定义对象持久化；　　 2、将对象从一个地方传递到另一个地方。　　 3、使程序更具维护性 当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为对象。 把对象转换为字节序列的过程称为对象的序列化。 把字节序列恢复为对象的过程称为对象的反序列化。 说的再直接点，序列化的目的就是为了跨进程传递格式化数据 Java 的灵活性体现在什么机制上？反射机制 Sleep 和 wait 的区别 1、sleep()方法，是属于 Thread 类中的。而 wait()方法，则是属于 Object 类中的。 2、在调用 sleep()方法的过程中，线程不会释放对象锁。而当调用 wait()方法的时候，线程会放弃对象锁。 sleep()方法导致了程序暂停执行指定的时间，让出 cpu 给其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。而当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备。IO 和 NIO1、IO 是面向流的，NIO 是面向缓冲区的。 Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO 的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。 2、Java IO 的各种流是阻塞的，Java NIO 的非阻塞模式。 Java IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 3、Java NIO 的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。而 Java IO 无选择器。Scoket 对于一个功能齐全的 Socket，都要包含以下基本结构，其工作过程包含以下四个基本的步骤： 　　（1） 创建 Socket； 　　（2） 打开连接到 Socket 的输入/出流； 　　（3） 按照一定的协议对 Socket 进行读/写操作； 　　（4） 关闭 Socket. 　　可参考博客： http://www.cnblogs.com/linzheng/archive/2011/01/23/1942328.html深克隆、浅克隆浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。 深复制把要复制的对象所引用的对象都复制了一遍。在 java 中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现。 在 c++中支持多继承，允许一个子类同时具有多个父类的接口和功能。UDP 和 TCPUDP 和 TCP 都属于传输层协议。 TCP 协议：面向连接的、可靠的、基于字节流 UDP 协议：无连接、不可靠、基于报文 1、TCP 协议中包含了专门的传递保证机制，当数据接收方收到发送方传来的信息时，会自动向发送方发出确认消息；发送方只有在接收到该确认消息之后才继续传送其它信息，否则将一直等待直到收到确认信息为止。 与 TCP 不同，UDP 协议并不提供数据传送的保证机制。如果在从发送方到接收方的传递过程中出现数据报的丢失，协议本身并不能做出任何检测或提示。因此，通常人们把 UDP 协议称为不可靠的传输协议。 2、相对于 TCP 协议，UDP 协议的另外一个不同之处在于如何接收突发性的多个数据报。不同于 TCP，UDP 并不能确保数据的发送和接收顺序。红黑树是一种自平衡二叉查找树，红黑树是一种很有意思的平衡检索树；每次插入的时候都要进行计算，保证二叉树的平衡；如果有 2 的 N 次方数据量级，查询的时候只需要查询 N 次即可。 我们对任何有效的红黑树加以如下增补要求: 1.节点是红色或黑色。 2.根是黑色。 3.所有叶子（外部节点）都是黑色。 4.每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 5.从每个叶子到根的所有路径都包含相同数目的黑色节点。 这些约束强制了红黑树的关键属性: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。反射反射机制指的是程序在运行时能够获取自身的信息。 用反射机制实现对数据库数据的增、查例子 。 基本原理：保存数据时，把需要保存的对象的属性值全部取出来再拼凑 sql 语句；查询时，将查询到的数据全部包装成一个 java 对象。 1）数据库的每一个表对应一个 pojo 类，表中的每一个字段对应 pojo 类的中的一个属性。 并且 pojo 类的名字和表的名字相同，属性名和字段名相同，大小写没有关系，因为数据库一般不区分大小写 2）为 pojo 类中的每一个属性添加标准的 set 和 get 方法。三次握手和四次挥手三次握手：首先 Client 端发送连接请求报文，Server 段接受连接后回复 ACK 报文，并为这次连接分配资源。Client 端接收到 ACK 报文后也向 Server 段发送 ACK 报文，并分配资源，这样 TCP 连接就建立了。四次握手： 由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 （1） TCP 客户端发送一个 FIN，用来关闭客户到服务器的数据传送。 （2） 服务器收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。 （3） 服务器关闭客户端的连接，发送一个 FIN 给客户端。 （4） 客户端发回 ACK 报文确认，并将确认序号设置为收到序号加 1。Equals()和==　　 1、java 中 equals 和==的区别 值类型是存储在内存中的堆栈（简称栈），而引用类型的变量在栈中仅仅是存储引用类型变量的地址，而其本身则存储在堆中。 　　 2、==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。 　　 3、equals 操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。 　　 4、==比较的是 2 个对象的地址，而 equals 比较的是 2 个对象的内容，显然，当 equals 为 true 时，==不一定为 true。
